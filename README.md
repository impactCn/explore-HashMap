# 总结
## 数据结构
* JDK7的HashMap
    * 由数组 + 单向链表组成
* JDK8的HashMap
    * 初始的时候：由数组 + 单向链表组成。
    * 当某个数组底下链表的长度大于等于8时：链表转成红黑树，由数组 + 链表 + 红黑树组成。
    * 当红黑树的节点小于等于6时：红黑树转成链表，由数组 + 链表组成。
* 红黑树的特点：
    * // todo
* 单向链表的特点：
    * 只需要修改元素钟的指针，在插入和删除需要O(1)。
    * 按序号查找，需要遍历全部，平均需要O(n)。
    * 按值查找，无论有序无序需要O(n)。
    * 只要有内存，元素个数不受限制。
* 数组的特点：
    * 按序号(数组下标)查找，需要O(1)。
    * 按值查找，无序需要O(n)，有序使用二分查找需要O(logN)
    * 添加与删除平均需要挪动n / 2个元素。
    * 分配相邻的内存地址，个数受分配的地址限制。

## 图解HashMap数据结构    

## 初始化长度
* 如果没有设置HashMap的初始化长度，默认长度为16
* 如果设置了HashMap的初始化长度，通过位运算都是2的幂次方，且大于等于2的幂次方。
    * 比如设置长度为1，则初始化长度为2
    * 比如设置长度为4，则初始化长度为4
    * 比如设置长度为10，则初始化长度为16
## 添加数据
* 第一：初始化数据结构、初始化HashMap长度
* 第二：计算key的hashCode，通过一系列的位扰动，确定key的hashCode。
* 第三：数组的位置由(长度 - 1) & key的hashCode决定。**注：由与&的位运算决定，所以2的次幂都要减1。**
* 第四：当key的hashCode产生hash碰撞，JDK8实行的是尾插入，JDK7实行的是头插入。
* 第五：当key与之前存入的key冲突时，替换原先的value。
* 第六：当链表长度大于等于8时，链表转红黑树，在插入。
* 第七：快速失败机制，对象的修改次数不等于迭代器的修改次数一样，抛出异常。
* 第八：当HashMap的长度达到阈值，即 初始化长度 * 0.75的时候，扩容一倍。
**注：假设初始化长度为16，当插入的时候，HashMap的长度来到 16 * 0.75，即12的时候，进行一倍的扩容，最终长度为32**

## JDK8的hashMap缺点的由来
// todo
## JDK7的hashMap缺点的由来
// todo
## 删除数据
// todo
## 查询数据
// todo
## JDK7和JDK8的比较
// todo

